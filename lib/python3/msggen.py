import textwrap
import enum
import pathlib
import re
import collections

OPCODE_BYTES = 1

PY_HEADER = """\
# THIS FILE WAS AUTOGENERATED
# DO NOT EDIT UNLESS YOU KNOW WHAT YOU'RE DOING

import struct
"""

PY_MESSAGE_TEMPLATE = r"""
class {class_name}(object):
{inner_classes}
    def __init__(self):
        pass
{init_lines}

    def __setattr__(self, name, value):
        if False:
            pass
{setattr_lines}
        else:
            msg = 'Attribute "{{}}" cannot be set'
            raise ValueError(msg.format(name))

    def validate(self):
        pass
{validate_lines}

    @classmethod
    def deserialize(cls, buffer, offset=0, getsize=False):
        init_offset = offset
        msg = cls()
{deserialize_lines}
        if getsize:
            return msg, offset - init_offset
        else:
            return msg

    def serialize(self):
        self.validate()
        buffer = []
{serialize_lines}
        return b"".join(buffer)

    def to_dict(self):
        return {{
{to_dict_lines}
        }}
"""

C_TEMPLATE = """\
/* THIS FILE WAS AUTOGENERATED
 * DO NOT EDIT UNLESS YOU KNOW WHAT YOU'RE DOING
 */
#pragma once
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include <stdbool.h>
{submsg_structs_fwd}
{submsg_structs}
struct {msg_name}
{{
{msg_fields}
}};

struct {msg_name} *{msg_name}_create()
{{
    struct {msg_name} *msg = malloc(sizeof(struct {msg_name}));
{create_lines}
    return msg;
}}

void {msg_name}_free(struct {msg_name} *msg)
{{
{free_lines}
    free(msg);
}}

void {msg_name}_validate(struct {msg_name} *msg)
{{
{validate_lines}
}}

unsigned char *{msg_name}_serialize(struct {msg_name} *msg, unsigned int *length)
{{
    *length = 0;
{serialize_length_lines}
    unsigned char *bytes = malloc(sizeof(unsigned char) * *length);
    unsigned char *ptr = bytes;
{serialize_memcpy_lines}
    return bytes;
}}

struct {msg_name} *{msg_name}_deserialize(unsigned char *bytes, unsigned int length)
{{
    unsigned char *ptr = bytes;
    struct {msg_name} *msg = malloc(sizeof(struct {msg_name}));
{deserialize_lines}
    return msg;
}}
"""

JS_TEMPLATE = """\
/* THIS FILE WAS AUTOGENERATED
 * DO NOT EDIT UNLESS YOU KNOW WHAT YOU'RE DOING
 */

{msg_name} = (function()
{{
    const encoder = new TextEncoder();
    const decoder = new TextDecoder();
{msg_classes}
    return {msg_name};
}}());

if (typeof(module.exports) !== "undefined")
{{
    module.exports.{msg_name} = {msg_name};
}}
"""

JS_MESSAGE_CLASS_TEMPLATE = """\
class {msg_name}
{{
    constructor()
    {{
{constructor_lines}
    }}
    validate()
    {{
{validate_lines}
    }}
    getsize()
    {{
        let size = 0;
{getsize_lines}
        return size;
    }}
    serialize()
    {{
        const buffer = new ArrayBuffer(this.getsize());
        const dataview = new DataView(buffer);
        this._serialize_inner(dataview, 0);
        return buffer;
    }}
    _serialize_inner(dataview, offset)
    {{
        const init_offset = offset;
{_serialize_inner_lines}
        return offset - init_offset;
    }}
    static deserialize(buffer)
    {{
        const dataview = new DataView(buffer);
        return {msg_name}._deserialize_inner(dataview, 0)[0];
    }}
    static _deserialize_inner(dataview, offset)
    {{
        const msg = new {msg_name}();
        const init_offset = offset;
{_deserialize_inner_lines}
        return [msg, offset - init_offset];
    }}
}}
"""


class Message(object):
    def __init__(self, name, msg_dict):
        self.name = name
        self.msg_dict = msg_dict

    @staticmethod
    def parse(msg_path):
        msg_path = pathlib.Path(msg_path)
        msg_dir = msg_path.parent
        submessages = {}
        msg_dict = collections.OrderedDict()
        no_comment_ptrn = re.compile(r"^([^#]*).*$")
        with msg_path.open() as f:
            lines = f.readlines()
        for i, raw_line in enumerate(lines):
            line = no_comment_ptrn.match(raw_line).group(1)
            tokens = line.split()
            if not tokens:
                continue
            if len(tokens) != 2:
                raise ValueError(f"Line {i} has the wrong number of tokens")
            typestring, name = tokens
            if name in msg_dict:
                raise ValueError(f"Line {i} has a name which already appeared")
            if typestring == "uint32":
                msg_dict[name] = FieldType.UINT32
            elif typestring == "f32":
                msg_dict[name] = FieldType.FLOAT32
            elif typestring == "bool":
                msg_dict[name] = FieldType.BOOL
            elif typestring == "string":
                msg_dict[name] = FieldType.STRING
            else:
                if typestring not in submessages:
                    submsg_path = msg_dir / (typestring + ".msg")
                    if not submsg_path.exists():
                        msg = (
                            "Line {} has non-primitive type {}, but message file "
                            "{} doesn't exist."
                        )
                        raise ValueError(msg.format(i, typestring, submsg_path))
                    submsg = Message.parse(submsg_path)
                    submessages[typestring] = submsg
                msg_dict[name] = submessages[typestring]
        name = msg_path.stem
        return Message(name=name, msg_dict=msg_dict)

    def validate(self):
        if not isinstance(self.name, str):
            raise ValueError("name must be a string")
        if not self.name.isidentifier():
            raise ValueError("name must be a valid identifier")
        for k, v in self.msg_dict.items():
            if not isinstance(k, str):
                raise ValueError("Keys must be strings")
            if not k:
                raise ValueError("Keys must be nonempty")
            if k.startswith("_"):
                raise ValueError('Keys must not start with "_"')
            if not k.isidentifier():
                raise ValueError("Keys must be valid identifiers")

            if isinstance(v, Message):
                v.validate()
            elif isinstance(v, FieldType):
                pass
            else:
                raise ValueError("Values must be of type FieldType or str")

    def gen_python(self):
        self.validate()
        msg_class = self._gen_python_inner()
        msg_module = "\n".join([PY_HEADER, msg_class])
        return msg_module

    def _gen_python_inner(self, class_name=None):
        if class_name is None:
            class_name = self.name

        INDENT = "    "
        INNER_CLASS_PREFIX = "__"
        inner_classes_buffer = []
        processed = set()
        for k, v in self.msg_dict.items():
            if isinstance(v, Message) and v.name not in processed:
                inner_class = v._gen_python_inner(INNER_CLASS_PREFIX + v.name)
                inner_classes_buffer.append(inner_class.strip())
                processed.add(v.name)
        inner_classes = textwrap.indent("\n\n".join(inner_classes_buffer), INDENT)
        if inner_classes:
            inner_classes = "\n{}\n".format(inner_classes)

        init_lines_buffer = []
        for k, v in self.msg_dict.items():
            if isinstance(v, Message):
                init_value = "self.{}()".format(INNER_CLASS_PREFIX + v.name)
            else:
                init_value = "None"
            init_lines_buffer.append(
                'super().__setattr__("{}", {})'.format(k, init_value)
            )
        init_lines = textwrap.indent("\n".join(init_lines_buffer), 2 * INDENT)

        setattr_lines_buffer = []
        for k, v in self.msg_dict.items():
            if isinstance(v, Message):
                raw_lines_pattern = r"""
                elif name == "{k}":
                    if not isinstance(value, self.{inner_name}):
                        raise ValueError('Attribute "{k}" must be a {inner_name} instance')
                    super().__setattr__("{k}", value)
                """
                raw_lines = raw_lines_pattern.format(
                    k=k, inner_name=INNER_CLASS_PREFIX + v.name
                )
            elif v == FieldType.BOOL:
                raw_lines_pattern = r"""
                elif name == "{k}":
                    value = bool(value)
                    super().__setattr__("{k}", value)
                """
                raw_lines = raw_lines_pattern.format(k=k)
            elif v == FieldType.UINT32:
                raw_lines_pattern = r"""
                elif name == "{k}":
                    value = int(value)
                    if not (0 <= value <= 2**32-1):
                        raise ValueError('Attribute "{k}" not in range [0, 4294967295]')
                    else:
                        super().__setattr__("{k}", value)
                """
                raw_lines = raw_lines_pattern.format(k=k)
            elif v == FieldType.FLOAT32:
                raw_lines_pattern = r"""
                elif name == "{k}":
                    value = float(value)
                    super().__setattr__("{k}", value)
                """
                raw_lines = raw_lines_pattern.format(k=k)
            elif v == FieldType.STRING:
                raw_lines_pattern = r"""
                elif name == "{k}":
                    if isinstance(value, bytes):
                        super().__setattr__("{k}", value.decode())
                    else:
                        super().__setattr__("{k}", str(value))
                """
                raw_lines = raw_lines_pattern.format(k=k)
            else:
                raise NotImplementedError(str(v))
            lines = textwrap.dedent(raw_lines).strip()
            setattr_lines_buffer.append(lines)
        setattr_lines = textwrap.indent("\n".join(setattr_lines_buffer), 2 * INDENT)

        validate_lines_buffer = []
        for k, v in self.msg_dict.items():
            if isinstance(v, Message):
                validate_lines_buffer.append("self.{k}.validate()".format(k=k))
            else:
                raw_lines = r"""
                if self.{k} is None:
                    raise ValueError('Attribute "{k}" is not initialized')
                """.format(
                    k=k
                )
                lines = textwrap.dedent(raw_lines).strip()
                validate_lines_buffer.append(lines)
        validate_lines = textwrap.indent("\n".join(validate_lines_buffer), 2 * INDENT)

        deserialize_lines_buffer = []
        for k, v in self.msg_dict.items():
            if isinstance(v, Message):
                raw_lines_pattern = r"""
                msg.{k}, delta = cls.{inner_class}.deserialize(buffer, offset, getsize=True)
                offset += delta
                """
                raw_lines = raw_lines_pattern.format(
                    k=k, inner_class=INNER_CLASS_PREFIX + v.name
                )
            elif v == FieldType.BOOL:
                raw_lines_pattern = r"""
                msg.{k} = struct.unpack_from("?", buffer, offset=offset)[0]
                offset += 1
                """
                raw_lines = raw_lines_pattern.format(k=k)
            elif v == FieldType.UINT32:
                raw_lines_pattern = r"""
                msg.{k} = struct.unpack_from("I", buffer, offset=offset)[0]
                offset += 4
                """
                raw_lines = raw_lines_pattern.format(k=k)
            elif v == FieldType.FLOAT32:
                raw_lines_pattern = r"""
                msg.{k} = struct.unpack_from("f", buffer, offset=offset)[0]
                offset += 4
                """
                raw_lines = raw_lines_pattern.format(k=k)
            elif v == FieldType.STRING:
                raw_lines_pattern = r"""
                str_len = struct.unpack_from("I", buffer, offset=offset)[0]
                offset += 4
                msg.{k} = struct.unpack_from("{{}}s".format(str_len), buffer, offset=offset)[0]
                offset += str_len
                """
                raw_lines = raw_lines_pattern.format(k=k)
            else:
                raise NotImplementedError(str(v))
            lines = textwrap.dedent(raw_lines).strip()
            deserialize_lines_buffer.append(lines)
        deserialize_lines = textwrap.indent(
            "\n".join(deserialize_lines_buffer), 2 * INDENT
        )

        serialize_lines_buffer = []
        for k, v in self.msg_dict.items():
            if isinstance(v, Message):
                raw_lines_pattern = r"""
                field = self.{k}.serialize()
                buffer.append(field)
                """
                raw_lines = raw_lines_pattern.format(k=k)
            elif v == FieldType.BOOL:
                raw_lines_pattern = r"""
                field = struct.pack("?", self.{k})
                buffer.append(field)
                """
                raw_lines = raw_lines_pattern.format(k=k)
            elif v == FieldType.UINT32:
                raw_lines_pattern = r"""
                field = struct.pack("I", self.{k})
                buffer.append(field)
                """
                raw_lines = raw_lines_pattern.format(k=k)
            elif v == FieldType.FLOAT32:
                raw_lines_pattern = r"""
                field = struct.pack("f", self.{k})
                buffer.append(field)
                """
                raw_lines = raw_lines_pattern.format(k=k)
            elif v == FieldType.STRING:
                raw_lines_pattern = r"""
                str_bytes = self.{k}.encode()
                field = struct.pack("I{{}}s".format(len(str_bytes)), len(str_bytes), str_bytes)
                buffer.append(field)
                """
                raw_lines = raw_lines_pattern.format(k=k)
            else:
                raise NotImplementedError(str(v))
            lines = textwrap.dedent(raw_lines).strip()
            serialize_lines_buffer.append(lines)
        serialize_lines = textwrap.indent("\n".join(serialize_lines_buffer), 2 * INDENT)

        to_dict_lines_buffer = []
        for k, v in self.msg_dict.items():
            if isinstance(v, Message):
                dict_value_pattern = "self.{k}.to_dict()"
            else:
                dict_value_pattern = "self.{k}"
            dict_value = dict_value_pattern.format(k=k)
            line_pattern = '"{k}": {dict_value},'
            line = line_pattern.format(k=k, dict_value=dict_value)
            to_dict_lines_buffer.append(line)
        to_dict_lines = textwrap.indent("\n".join(to_dict_lines_buffer), 3 * INDENT)

        return PY_MESSAGE_TEMPLATE.format(
            class_name=class_name,
            inner_classes=inner_classes,
            init_lines=init_lines,
            setattr_lines=setattr_lines,
            validate_lines=validate_lines,
            deserialize_lines=deserialize_lines,
            serialize_lines=serialize_lines,
            to_dict_lines=to_dict_lines,
        )

    def gen_c(self):
        self.validate()
        INDENT = "    "
        SUBMESSAGE_PREFIX = "__{}_".format(self.name)
        all_submessages_dict = {}
        fields = list(self.msg_dict.values())
        while fields:
            next_fields = []
            for field in fields:
                if isinstance(field, Message):
                    next_fields.extend(field.msg_dict.values())
                    all_submessages_dict[field.name] = field
            fields = next_fields
        all_submessages = sorted(all_submessages_dict.items())

        def get_field_lines(msg):
            lines = []
            for k, v in msg.msg_dict.items():
                if isinstance(v, Message):
                    v_name = v.name
                    lines.append(f"{INDENT}struct {SUBMESSAGE_PREFIX}{v_name} {k};")
                elif v == FieldType.BOOL:
                    lines.append(f"{INDENT}bool {k};")
                elif v == FieldType.UINT32:
                    lines.append(f"{INDENT}unsigned int {k};")
                elif v == FieldType.FLOAT32:
                    lines.append(f"{INDENT}float {k};")
                elif v == FieldType.STRING:
                    lines.append(f"{INDENT}char *{k};")
                else:
                    raise NotImplementedError(str(v))
            return lines

        submsg_structs_fwd_buffer = []
        submsg_structs_buffer = []
        for name, msg in all_submessages:
            mangled_name = f"{SUBMESSAGE_PREFIX}{name}"
            submsg_structs_fwd_buffer.append(f"struct {mangled_name};")
            struct_buffer = []
            struct_buffer.append(f"struct {mangled_name}\n{{")
            struct_buffer.extend(get_field_lines(msg))
            struct_buffer.append("};")
            submsg_structs_buffer.append("\n".join(struct_buffer))

        submsg_structs_fwd = "\n".join(submsg_structs_fwd_buffer)
        submsg_structs = "\n".join(submsg_structs_buffer)

        msg_fields = "\n".join(get_field_lines(self))

        flat_msg_dict = collections.OrderedDict()

        def add_flattened_fields(flat_msg_dict, msg, prefix=""):
            for k, v in msg.msg_dict.items():
                if isinstance(v, Message):
                    add_flattened_fields(flat_msg_dict, v, prefix=f"{prefix}{k}.")
                else:
                    flat_msg_dict[f"{prefix}{k}"] = v

        add_flattened_fields(flat_msg_dict, self)

        create_lines_buffer = []
        for k, v in flat_msg_dict.items():
            pass
        create_lines = "\n".join(create_lines_buffer)

        free_lines_buffer = []
        for k, v in flat_msg_dict.items():
            if v == FieldType.STRING:
                free_lines_buffer.extend(
                    [
                        f"{INDENT}if (msg->{k})",
                        f"{INDENT}{{",
                        f"{INDENT}{INDENT}free(msg->{k});",
                        f"{INDENT}}}",
                    ]
                )
        free_lines = "\n".join(free_lines_buffer)

        validate_lines_buffer = []
        for k, v in flat_msg_dict.items():
            if v == FieldType.STRING:
                validate_lines_buffer.append(f"{INDENT}assert(msg->{k});")
        validate_lines = "\n".join(validate_lines_buffer)

        serialize_length_lines_buffer = []
        serialize_memcpy_lines_buffer = []
        for k, v in flat_msg_dict.items():
            if v == FieldType.STRING:
                serialize_length_lines_buffer.extend(
                    [f"{INDENT}*length += 4;", f"{INDENT}*length += strlen(msg->{k});"]
                )
                serialize_memcpy_lines_buffer.extend(
                    [
                        f"{INDENT}{{",
                        f"{INDENT}{INDENT}unsigned int str_len = strlen(msg->{k});",
                        f"{INDENT}{INDENT}memcpy(ptr, &str_len, 4);",
                        f"{INDENT}{INDENT}ptr += 4;",
                        f"{INDENT}{INDENT}memcpy(ptr, msg->{k}, str_len);",
                        f"{INDENT}{INDENT}ptr += str_len;",
                        f"{INDENT}}}",
                    ]
                )
            elif v == FieldType.BOOL:
                serialize_length_lines_buffer.append(f"{INDENT}*length += 1;")
                serialize_memcpy_lines_buffer.extend(
                    [f"{INDENT}memcpy(ptr, &msg->{k}, 1);", f"{INDENT}ptr += 1;"]
                )
            elif v == FieldType.UINT32:
                serialize_length_lines_buffer.append(f"{INDENT}*length += 4;")
                serialize_memcpy_lines_buffer.extend(
                    [f"{INDENT}memcpy(ptr, &msg->{k}, 4);", f"{INDENT}ptr += 4;"]
                )
            elif v == FieldType.FLOAT32:
                serialize_length_lines_buffer.append(f"{INDENT}*length += 4;")
                serialize_memcpy_lines_buffer.extend(
                    [f"{INDENT}memcpy(ptr, &msg->{k}, 4);", f"{INDENT}ptr += 4;"]
                )
            else:
                raise NotImplementedError(str(v))
        serialize_length_lines = "\n".join(serialize_length_lines_buffer)
        serialize_memcpy_lines = "\n".join(serialize_memcpy_lines_buffer)

        deserialize_lines_buffer = []
        for k, v in flat_msg_dict.items():
            if v == FieldType.STRING:
                deserialize_lines_buffer.extend(
                    [
                        f"{INDENT}{{",
                        f"{INDENT}{INDENT}unsigned int str_len;",
                        f"{INDENT}{INDENT}memcpy(&str_len, ptr, 4);",
                        f"{INDENT}{INDENT}ptr += 4;",
                        f"{INDENT}{INDENT}msg->{k} = malloc(sizeof(char) * (str_len + 1));",
                        f"{INDENT}{INDENT}memcpy(msg->{k}, ptr, str_len);",
                        f"{INDENT}{INDENT}msg->{k}[str_len] = 0;",
                        f"{INDENT}{INDENT}ptr += str_len;",
                        f"{INDENT}}}",
                    ]
                )
            elif v == FieldType.BOOL:
                deserialize_lines_buffer.extend(
                    [f"{INDENT}memcpy(&msg->{k}, ptr, 1);", f"{INDENT}ptr += 1;"]
                )
            elif v == FieldType.UINT32:
                deserialize_lines_buffer.extend(
                    [f"{INDENT}memcpy(&msg->{k}, ptr, 4);", f"{INDENT}ptr += 4;"]
                )
            elif v == FieldType.FLOAT32:
                deserialize_lines_buffer.extend(
                    [f"{INDENT}memcpy(&msg->{k}, ptr, 4);", f"{INDENT}ptr += 4;"]
                )
            else:
                raise NotImplementedError(v)
        deserialize_lines = "\n".join(deserialize_lines_buffer)

        return C_TEMPLATE.format(
            msg_name=self.name,
            submsg_structs_fwd=submsg_structs_fwd,
            submsg_structs=submsg_structs,
            msg_fields=msg_fields,
            create_lines=create_lines,
            free_lines=free_lines,
            validate_lines=validate_lines,
            serialize_length_lines=serialize_length_lines,
            serialize_memcpy_lines=serialize_memcpy_lines,
            deserialize_lines=deserialize_lines,
        )

    def gen_javascript(self):
        INDENT = "    "
        MANGLE_PREFIX = "__"

        def _gen_javascript_class(msg, msg_name):
            constructor_lines_buffer = []
            for k, v in msg.msg_dict.items():
                if isinstance(v, Message):
                    field_type = MANGLE_PREFIX + v.name
                    constructor_lines_buffer.append(f"this.{k} = new {field_type}();")
                else:
                    constructor_lines_buffer.append(f"this.{k} = null;")
            constructor_lines = textwrap.indent(
                "\n".join(constructor_lines_buffer), 2 * INDENT
            )

            validate_lines_buffer = []
            for k, v in msg.msg_dict.items():
                if isinstance(v, Message):
                    validate_lines_buffer.append(f"this.{k}.validate();")
                else:
                    validate_lines_buffer.extend(
                        [
                            f"if (this.{k} === null)",
                            "{",
                            f"{INDENT}throw new Error('Attribute \"{k}\" is not initialized');",
                            "}",
                        ]
                    )
            validate_lines = textwrap.indent(
                "\n".join(validate_lines_buffer), 2 * INDENT
            )

            getsize_lines_buffer = []
            for k, v in msg.msg_dict.items():
                if isinstance(v, Message):
                    getsize_lines_buffer.append(f"size += this.{k}.getsize();")
                elif v == FieldType.BOOL:
                    getsize_lines_buffer.append("size += 1;")
                elif v == FieldType.UINT32:
                    getsize_lines_buffer.append("size += 4;")
                elif v == FieldType.FLOAT32:
                    getsize_lines_buffer.append("size += 4;")
                elif v == FieldType.STRING:
                    getsize_lines_buffer.extend(
                        ["size += 4;", f"size += encoder.encode(this.{k}).byteLength;"]
                    )
                else:
                    raise NotImplementedError(str(v))
            getsize_lines = textwrap.indent("\n".join(getsize_lines_buffer), 2 * INDENT)

            _serialize_inner_lines_buffer = []
            for k, v in msg.msg_dict.items():
                if isinstance(v, Message):
                    _serialize_inner_lines_buffer.append(
                        f"offset += this.{k}._serialize_inner(dataview, offset);"
                    )
                elif v == FieldType.BOOL:
                    _serialize_inner_lines_buffer.extend(
                        [f"dataview.setUint8(offset, this.{k});", "offset += 1;"]
                    )
                elif v == FieldType.UINT32:
                    _serialize_inner_lines_buffer.extend(
                        [f"dataview.setUint32(offset, this.{k}, true);", "offset += 4;"]
                    )
                elif v == FieldType.FLOAT32:
                    _serialize_inner_lines_buffer.extend(
                        [
                            f"dataview.setFloat32(offset, this.{k}, true);",
                            "offset += 4;",
                        ]
                    )
                elif v == FieldType.STRING:
                    _serialize_inner_lines_buffer.extend(
                        [
                            "{",
                            f"{INDENT}const bytes = encoder.encode(this.{k});",
                            f"{INDENT}dataview.setUint32(offset, bytes.length, true);",
                            f"{INDENT}offset += 4;",
                            f"{INDENT}for (let b in bytes)",
                            f"{INDENT}{{",
                            f"{INDENT}{INDENT}dataview.setUint8(offset, bytes[b]);",
                            f"{INDENT}{INDENT}offset += 1;",
                            f"{INDENT}}}",
                            "}",
                        ]
                    )
                else:
                    raise NotImplementedError(str(v))
            _serialize_inner_lines = textwrap.indent(
                "\n".join(_serialize_inner_lines_buffer), 2 * INDENT
            )

            _deserialize_inner_lines_buffer = []
            for k, v in msg.msg_dict.items():
                if isinstance(v, Message):
                    mangled_name = MANGLE_PREFIX + v.name
                    _deserialize_inner_lines_buffer.extend(
                        [
                            "{",
                            f"{INDENT}let delta;",
                            f"{INDENT}[msg.{k}, delta] = {mangled_name}._deserialize_inner(dataview, offset);",
                            f"{INDENT}offset += delta;",
                            "}",
                        ]
                    )
                elif v == FieldType.BOOL:
                    _deserialize_inner_lines_buffer.extend(
                        [f"msg.{k} = !!dataview.getUint8(offset);", "offset += 1;"]
                    )
                elif v == FieldType.UINT32:
                    _deserialize_inner_lines_buffer.extend(
                        [f"msg.{k} = dataview.getUint32(offset, true);", "offset += 4;"]
                    )
                elif v == FieldType.FLOAT32:
                    _deserialize_inner_lines_buffer.extend(
                        [
                            f"msg.{k} = dataview.getFloat32(offset, true);",
                            "offset += 4;",
                        ]
                    )
                elif v == FieldType.STRING:
                    _deserialize_inner_lines_buffer.extend(
                        [
                            "{",
                            f"{INDENT}const str_len = dataview.getUint32(offset, true);",
                            f"{INDENT}offset += 4;",
                            f"{INDENT}const buffer = new Uint8Array(str_len);",
                            f"{INDENT}for (let i = 0; i < str_len; ++i)",
                            f"{INDENT}{{",
                            f"{INDENT}{INDENT}buffer[i] = dataview.getUint8(offset + i);",
                            f"{INDENT}}}",
                            f"{INDENT}msg.{k} = decoder.decode(buffer);",
                            f"{INDENT}offset += str_len;",
                            "}",
                        ]
                    )
                else:
                    raise NotImplementedError(str(v))
            _deserialize_inner_lines = textwrap.indent(
                "\n".join(_deserialize_inner_lines_buffer), 2 * INDENT
            )
            return JS_MESSAGE_CLASS_TEMPLATE.format(
                msg_name=msg_name,
                constructor_lines=constructor_lines,
                validate_lines=validate_lines,
                getsize_lines=getsize_lines,
                _serialize_inner_lines=_serialize_inner_lines,
                _deserialize_inner_lines=_deserialize_inner_lines,
            )

        msg_name = self.name
        messages = collections.OrderedDict([(self.name, self)])
        fields = list(self.msg_dict.values())
        while fields:
            next_fields = []
            for field in fields:
                if isinstance(field, Message):
                    submsg_name = MANGLE_PREFIX + field.name
                    if submsg_name not in messages:
                        messages[submsg_name] = field
                    next_fields.extend(field.msg_dict.values())
                fields = next_fields
        msg_classes_buffer = []
        for msg_classname, msg in messages.items():
            msg_classes_buffer.append(_gen_javascript_class(msg, msg_classname))
        msg_classes = textwrap.indent("\n".join(msg_classes_buffer), INDENT)
        return JS_TEMPLATE.format(msg_name=msg_name, msg_classes=msg_classes)


class FieldType(enum.Enum):
    UINT32 = enum.auto()
    FLOAT32 = enum.auto()
    STRING = enum.auto()
    BOOL = enum.auto()
